// 소유권(Ownership)이란 러스트의 가장 유니크한 특성이다.
// ! 러스트가 가비지컬렉터 없이 메모리 안정성을 보장해주는 역할을 한다.

// 다른 언어들의 메모리 관리법은 크게 두가지로 나뉜다.
// 1. 명시적으로 할당 및 해제
// 2. 사용하지 않는 메모리를 끊임없이 찾는 가비지컬렉터를 사용

// 러스트는 저 두가지 방법이 아닌 3번째 방법을 이용한다.
// 그것이 바로 소유권 시스템이며, 소유권 시스템은 어떠한 런타임 비용도 발생하지 않는다. 즉, 메모리 관리에 어떠한 런타임 비용도 발생하지 않는 것이다.
// 러스트의 특별한 메모리관리법은 다른 것은 힙에 저장되는 데이터타입들만이다.

/*
소유권 규칙
1. 러스트 각각의 값은 해당값의 오너(owner)라고 불리는 변수를 갖고 있다.
2. 한번에 딱 하나의 오너만 존재가능
3. 오너가 스코프밖으로 벗어날때, 값은 버려진다.
*/

fn ownership_test1() {
    let _s = "hello"; // _s는 이때부터 유효
} // 이 스코프는 이제 끝이므로, _s는 더이상 유효하지 않음.

fn ownership_test2() {

}

fn string_test() {
    // 문자열 리터럴은 변경이 불가능하지만 스트링은 조작이 가능
    let mut s = String::from("Hello");
    s.push_str(", world!");
    println!("{}", s);

    // 왜? 문자열 리터럴은 내용물을 컴파일 타임에 알수 있으므로 문자열이 최종실행파일에 하드코딩 되어있다.
    // 그렇기에 이미 바이너리 파일에 박혀있는 텍스트를 바꿀순 없으므로 문자열 리터럴은 변경이 불가능하다.

    // string은 변경이 가능한 문자열타입이므로, 다음의 요구조건이 붙는다.
    // 1. 런타임에 운영체제로부터 메모리 요청이 되어야 한다. -> String::from()이 이 역할을 한다.
    // 2. 사용이 끝났을때 운영체제에게 메모리를 반납할 방법이 필요하다.

    // 2번의 요구조건이 어떻게 충족될까? GC(가비지컬렉터)도 없는데 말이다.
    // 러스트는 변수가 유효한 스코프를 벗어나는 순간 자동으로 메모리를 해제하며 반납을 하는 방식으로 이를 해결하였다.
    // 벗어나는 순간 drop()이라는 함수를 통하여 자동으로 반납을 한다. -> 그럼 drop() 함수를 사용자정의 타입에 따라 구현해주어야되나.. 이건 알아봐야겠다.
    // C++에서는  수명주기가 끝나는 시점에 바로 해제하는 이 drop() 패턴을 RAII 패턴이라고 한다.
}

fn string_test2() {
    
}

fn main() {
    ownership_test1();
    ownership_test2();
    string_test();
}