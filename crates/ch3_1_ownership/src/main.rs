// 소유권(Ownership)이란 러스트의 가장 유니크한 특성이다.
// ! 러스트가 가비지컬렉터 없이 메모리 안정성을 보장해주는 역할을 한다.

// 다른 언어들의 메모리 관리법은 크게 두가지로 나뉜다.
// 1. 명시적으로 할당 및 해제
// 2. 사용하지 않는 메모리를 끊임없이 찾는 가비지컬렉터를 사용

// 러스트는 저 두가지 방법이 아닌 3번째 방법을 이용한다.
// 그것이 바로 소유권 시스템이며, 소유권 시스템은 어떠한 런타임 비용도 발생하지 않는다. 즉, 메모리 관리에 어떠한 런타임 비용도 발생하지 않는 것이다.
// 러스트의 특별한 메모리관리법은 다른 것은 힙에 저장되는 데이터타입들만이다.

/*
소유권 규칙
1. 러스트 각각의 값은 해당값의 오너(owner)라고 불리는 변수를 갖고 있다.
2. 한번에 딱 하나의 오너만 존재가능
3. 오너가 스코프밖으로 벗어날때, 값은 버려진다.
*/

fn ownership_test1() {
    let _s = "hello"; // _s는 이때부터 유효
} // 이 스코프는 이제 끝이므로, _s는 더이상 유효하지 않음.

fn ownership_test2() {

}

fn ownership_test3() {
    // 문자열 리터럴은 변경이 불가능하지만 스트링은 조작이 가능
    let mut s = String::from("Hello");
    s.push_str(", world!");
    println!("{}", s);

    // 왜? 문자열 리터럴은 내용물을 컴파일 타임에 알수 있으므로 문자열이 최종실행파일에 하드코딩 되어있다.
    // 그렇기에 이미 바이너리 파일에 박혀있는 텍스트를 바꿀순 없으므로 문자열 리터럴은 변경이 불가능하다.

    // string은 변경이 가능한 문자열타입이므로, 다음의 요구조건이 붙는다.
    // 1. 런타임에 운영체제로부터 메모리 요청이 되어야 한다. -> String::from()이 이 역할을 한다.
    // 2. 사용이 끝났을때 운영체제에게 메모리를 반납할 방법이 필요하다.

    // 2번의 요구조건이 어떻게 충족될까? GC(가비지컬렉터)도 없는데 말이다.
    // 러스트는 변수가 유효한 스코프를 벗어나는 순간 자동으로 메모리를 해제하며 반납을 하는 방식으로 이를 해결하였다.
    // 벗어나는 순간 drop()이라는 함수를 통하여 자동으로 반납을 한다. -> 그럼 drop() 함수를 사용자정의 타입에 따라 구현해주어야되나.. 이건 알아봐야겠다.
    // C++에서는  수명주기가 끝나는 시점에 바로 해제하는 이 drop() 패턴을 RAII 패턴이라고 한다.
}

fn ownership_test4() {
    let s1 = String::from("hello");
    // 이렇게 힙에서 관리되는 데이터를 대입하였을 때는 "얕은 복사"를 한다.
    // 즉, 메모리 상의 데이터를 복사하는 것이 아닌, 스택에 있는 포인터, 길이값, 용량값만 복사가 된다.
    // 그렇기에 s1과 s2는 같은 메모리를 참조하고 있다.
    let s2 = s1;

    // 그런데 스코프를 벗어나면 drop함수를 호출하여 메모리를 해제한다고 하였다.
    // 지금 상황이라면 두번 해제가 되어, 해제된 메모리를 또 해제할거기에 에러가 날 것이다.

    // 그래서 rust는 이런상황을 막기 위해 "소유권"을 넘긴다. Unique포인터를 생각하면 된다.
    // 오직 한개만 소유권을 들고 있을 수 있기 때문에 s1의 소유권이 s2에게 넘어가며 s1은 유효하지 않은 값으로 변경한다. 이를 이동이라고 한다.
    // 그렇기에 지금 s1에 접근하면 에러가 난다.
    // println!("{}, world!", s1) // 에러!
}

fn ownership_test5() {
    // String같이 힙에서 저장되는 타입을 스택 데이터만이 아니라 힙 데이터까지 같이 복사하기를 원할 수 있다.
    // 그럴때 사용하는 것이 clone 함수이다.
    // clone은 스택, 힙 데이터 모두 깊은복사를 하여 리턴해준다.

    let s1 = String::from("hello");
    let s2 = s1.clone();

    // 이제 에러가 나지 않는다!
    println!("s1 = {}, s2 = {}", s1, s2);
}

fn ownership_test6() {
    let x = 5;
    // 이렇게 y에 대입해도 x는 유효한값으로 남아있다.
    let y = x;

    // 대입하는 타입이 Copy 트레잇을 구현하고 있다면, 대입 과정 후에도 예전 변수를 계속 유지 및 사용할 수 있다.
    // 정수형, 부동소수형, bool, copy가 가능한 타입으로만 구성된 튜플타입등 스택에 저장할수 있는 타입들은 Copy트레잇을 가지고 있다. 
    // 대입하고 유효하지 않은 값으로 바뀌는 타입들은 drop 트레잇을 구현하고 있다.
    // drop 트레잇을 구현한 타입은 copy 트레잇을 구현하지 못하며 반대도 마찬가지다. 

    println!("x = {}, y = {}", x, y);
}

fn ownership_test7() {
     // gives_ownership 함수는 반환값의 소유권을 s1에게 이동시킨다.
    let s1 = gives_ownership();

     // s2가 스코프안으로 들어오며 소유권은 s2에게 있다.
    let s2 = String::from("hello");

    // s2의 소유권은 takes_and_gives_back 함수안으로 이동되었다.  
    // 함수안으로 이동한 소유권은 리턴하며 다시 s3로 이동이 된다.
    // 현재 s2는 유효하지 않은 값으로 설정이 되어있다. 
    let s3 = takes_and_gives_back(s2); 

    // 함수에 매개변수로 힙할당타입이 들어가면 소유권을 무조건 잃게 된다.
    // 그렇기에 여러가지 힙할당타입을 매개변수로 받으면 최소 한가지를 제외한 나머지 타입들은 소유권을 잃어버린다.
    // 이를 해결할 방법이 없을까?
    // 임시적인 해결방법으로는 튜플로 매개변수를 리턴하여 소유권을 다시 돌려주는 방법이 있다.
}

fn gives_ownership() -> String {
    let some_string = String::from("hello");
    some_string
}

fn takes_and_gives_back(in_string: String) -> String {
    in_string
}

fn ownership_test8() {
    let s1 = String::from("hello");

    // 이런 식으로 튜플로 받으면 모든 매개변수들의 소유권을 다시 돌려받을 수 있다.
    // 하지만, 매번 이런식으로 소유권을 잃고 다시 돌려받아야 하는 과정이 너무 귀찮고 복잡하다.
    // 그래서 참조자(reference)가 있다. 다른 언어들과 비슷한 의미이다.
    // 참조자도 내용이 많기에 다음 cargo에서 정리하겠다.
    let (s2, len) = calculate_strlen(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_strlen(s: String) -> (String, usize) {
    let length = s.len();
    (s, length)
}

fn main() {
    ownership_test1();
    ownership_test2();
    ownership_test3();
    ownership_test4();
    ownership_test5();
    ownership_test6();
    ownership_test7();
    ownership_test8();
}